--- src/test/java/hudson/plugins/buildblocker/BuildBlockerQueueTaskDispatcherTest.java
+++ src/test/java/hudson/plugins/buildblocker/BuildBlockerQueueTaskDispatcherTest.java
@@ -29,7 +29,6 @@ import hudson.model.Computer;
 import hudson.model.Executor;
 import hudson.model.FreeStyleBuild;
 import hudson.model.FreeStyleProject;
-import hudson.model.Hudson;
 import hudson.model.Label;
 import hudson.model.Queue;
 import hudson.model.Run;
@@ -38,34 +37,43 @@ import hudson.model.queue.CauseOfBlockage;
 import hudson.slaves.DumbSlave;
 import hudson.slaves.SlaveComputer;
 import hudson.tasks.Shell;
-import org.jvnet.hudson.test.HudsonTestCase;
+import org.junit.Rule;
+import org.junit.Test;
+import org.jvnet.hudson.test.JenkinsRule;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.concurrent.Future;
 
-import static hudson.model.Hudson.getInstance;
 import static org.hamcrest.Matchers.lessThanOrEqualTo;
 import static org.hamcrest.core.Is.is;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * Unit tests
  */
-public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
+public class BuildBlockerQueueTaskDispatcherTest {
+
+    @Rule
+    public JenkinsRule j = new JenkinsRule();
 
     /**
      * One test for all for faster execution.
      *
      * @throws Exception
      */
+    @Test
     public void testCanRun() throws Exception {
         // init slave
         LabelAtom slaveLabel = new LabelAtom("slave");
-        LabelAtom masterLabel = new LabelAtom("master");
+        LabelAtom masterLabel = new LabelAtom("built-in");
 
-        DumbSlave slave = this.createSlave(slaveLabel);
+        DumbSlave slave = j.createSlave(slaveLabel);
         SlaveComputer c = slave.getComputer();
         c.connect(false).get(); // wait until it's connected
         if (c.isOffline()) {
@@ -82,7 +90,7 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         Future<FreeStyleBuild> future2 = createBlockingProject(blockingJobName, shell, masterLabel);
         Future<FreeStyleBuild> future3 = createBlockingProject("yyy", shell, slaveLabel);
         // add project to slave
-        FreeStyleProject project = this.createFreeStyleProject();
+        FreeStyleProject project = j.createFreeStyleProject();
         project.setAssignedLabel(slaveLabel);
 
         Queue.BuildableItem item = new Queue.BuildableItem(new Queue.WaitingItem(Calendar.getInstance(), project, new ArrayList<Action>()));
@@ -109,15 +117,16 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         }
     }
 
+    @Test
     public void testMultipleExecutors() throws Exception {
 
         // Job1 runs for 1 second, no dependencies
-        FreeStyleProject theJob1 = createFreeStyleProject("MultipleExecutor_Job1");
+        FreeStyleProject theJob1 = j.createFreeStyleProject("MultipleExecutor_Job1");
         theJob1.getBuildersList().add(new Shell("sleep 1; exit 0"));
         assertTrue(theJob1.getBuilds().isEmpty());
 
         // Job2 returns immediatly but can't run while Job1 is running.
-        FreeStyleProject theJob2 = createFreeStyleProject("MultipleExecutor_Job2");
+        FreeStyleProject theJob2 = j.createFreeStyleProject("MultipleExecutor_Job2");
         {
             BuildBlockerProperty theProperty = new BuildBlockerPropertyBuilder()
                     .setBlockingJobs("MultipleExecutor_Job1")
@@ -130,8 +139,8 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         assertTrue(theJob1.getBuilds().isEmpty());
 
         // allow executing two simultanious jobs
-        int theOldNumExecutors = getInstance().getNumExecutors();
-        getInstance().setNumExecutors(2);
+        int theOldNumExecutors = j.jenkins.getNumExecutors();
+        j.jenkins.setNumExecutors(2);
 
         Future<FreeStyleBuild> theFuture1 = theJob1.scheduleBuild2(0);
         Future<FreeStyleBuild> theFuture2 = theJob2.scheduleBuild2(0);
@@ -145,11 +154,12 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         assertTrue(theRun1.getTimeInMillis() + theRun1.getDuration() <= theRun2.getTimeInMillis());
 
         // restore changed settings
-        getInstance().setNumExecutors(theOldNumExecutors);
+        j.jenkins.setNumExecutors(theOldNumExecutors);
         theJob2.delete();
         theJob1.delete();
     }
 
+    @Test
     public void testSelfExcludingJobs() throws Exception {
 
         BuildBlockerProperty theProperty = new BuildBlockerPropertyBuilder()
@@ -159,17 +169,17 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
                 .setScanBuildableQueueItemStates()
                 .createBuildBlockerProperty();
 
-        FreeStyleProject theJob1 = createFreeStyleProject("SelfExcluding_Job1");
+        FreeStyleProject theJob1 = j.createFreeStyleProject("SelfExcluding_Job1");
         theJob1.addProperty(theProperty);
         assertTrue(theJob1.getBuilds().isEmpty());
 
-        FreeStyleProject theJob2 = createFreeStyleProject("SelfExcluding_Job2");
+        FreeStyleProject theJob2 = j.createFreeStyleProject("SelfExcluding_Job2");
         theJob2.addProperty(theProperty);
         assertTrue(theJob2.getBuilds().isEmpty());
 
         // allow executing two simultanious jobs
-        int theOldNumExecutors = getInstance().getNumExecutors();
-        getInstance().setNumExecutors(2);
+        int theOldNumExecutors = j.jenkins.getNumExecutors();
+        j.jenkins.setNumExecutors(2);
 
         Future<FreeStyleBuild> theFuture1 = theJob1.scheduleBuild2(0);
         Future<FreeStyleBuild> theFuture2 = theJob2.scheduleBuild2(0);
@@ -179,7 +189,7 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         while ((!theFuture1.isDone() || !theFuture2.isDone())
                 && theEndTime < theStartTime + 5000) {
             int countBusy = 0;
-            for (Computer computor : Hudson.getInstance().getComputers()) {
+            for (Computer computor : j.jenkins.getComputers()) {
                 for (Executor executor : computor.getExecutors()) {
                     if (executor.isBusy()) {
                         countBusy++;
@@ -195,7 +205,7 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
         assertTrue(theEndTime < theStartTime + 5000);
 
         // restore changed settings
-        getInstance().setNumExecutors(theOldNumExecutors);
+        j.jenkins.setNumExecutors(theOldNumExecutors);
         theJob2.delete();
         theJob1.delete();
     }
@@ -211,7 +221,7 @@ public class BuildBlockerQueueTaskDispatcherTest extends HudsonTestCase {
      */
     private Future<FreeStyleBuild> createBlockingProject(String blockingJobName, Shell shell, Label label) throws
             IOException {
-        FreeStyleProject blockingProject = this.createFreeStyleProject(blockingJobName);
+        FreeStyleProject blockingProject = j.createFreeStyleProject(blockingJobName);
         blockingProject.setAssignedLabel(label);
 
         blockingProject.getBuildersList().add(shell);
